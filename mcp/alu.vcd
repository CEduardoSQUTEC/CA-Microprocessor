$date
	Mon Jul 13 12:11:31 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module controller_tb $end
$var wire 3 ! alucontrol [2:0] $end
$var wire 1 " alusrca $end
$var wire 2 # alusrcb [1:0] $end
$var wire 1 $ iord $end
$var wire 1 % irwrite $end
$var wire 1 & memtoreg $end
$var wire 1 ' memwrite $end
$var wire 1 ( pcen $end
$var wire 2 ) pcsrc [1:0] $end
$var wire 1 * regdst $end
$var wire 1 + regwrite $end
$var reg 1 , clk $end
$var reg 15 - errors [14:0] $end
$var reg 6 . funct [5:0] $end
$var reg 6 / op [5:0] $end
$var reg 1 0 reset $end
$var reg 15 1 result [14:0] $end
$var reg 15 2 result_expected [14:0] $end
$var reg 15 3 vectornum [14:0] $end
$var reg 1 4 zero $end
$scope module dut $end
$var wire 3 5 alucontrol [2:0] $end
$var wire 1 " alusrca $end
$var wire 2 6 alusrcb [1:0] $end
$var wire 1 , clk $end
$var wire 6 7 funct [5:0] $end
$var wire 1 $ iord $end
$var wire 1 % irwrite $end
$var wire 1 & memtoreg $end
$var wire 1 ' memwrite $end
$var wire 6 8 op [5:0] $end
$var wire 1 ( pcen $end
$var wire 2 9 pcsrc [1:0] $end
$var wire 1 * regdst $end
$var wire 1 + regwrite $end
$var wire 1 0 reset $end
$var wire 1 4 zero $end
$var wire 1 : pcwrite $end
$var wire 1 ; branch $end
$var wire 2 < aluop [1:0] $end
$scope module ad $end
$var wire 6 = funct [5:0] $end
$var wire 2 > aluop [1:0] $end
$var reg 3 ? alucontrol [2:0] $end
$upscope $end
$scope module md $end
$var wire 1 " alusrca $end
$var wire 2 @ alusrcb [1:0] $end
$var wire 1 , clk $end
$var wire 1 $ iord $end
$var wire 1 % irwrite $end
$var wire 1 & memtoreg $end
$var wire 1 ' memwrite $end
$var wire 6 A op [5:0] $end
$var wire 2 B pcsrc [1:0] $end
$var wire 1 * regdst $end
$var wire 1 + regwrite $end
$var wire 1 0 reset $end
$var wire 1 : pcwrite $end
$var wire 1 ; branch $end
$var wire 2 C aluop [1:0] $end
$var reg 15 D controls [14:0] $end
$var reg 4 E nextstate [3:0] $end
$var reg 4 F state [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mips $end
$var wire 32 G adr [31:0] $end
$var wire 1 H clk $end
$var wire 32 I readdata [31:0] $end
$var wire 1 J reset $end
$var wire 32 K writedata [31:0] $end
$var wire 1 L zero $end
$var wire 1 M regwrite $end
$var wire 1 N regdst $end
$var wire 2 O pcsrc [1:0] $end
$var wire 1 P pcen $end
$var wire 6 Q op [5:0] $end
$var wire 1 R memwrite $end
$var wire 1 S memtoreg $end
$var wire 1 T irwrite $end
$var wire 1 U iord $end
$var wire 6 V funct [5:0] $end
$var wire 2 W alusrcb [1:0] $end
$var wire 1 X alusrca $end
$var wire 3 Y alucontrol [2:0] $end
$scope module c $end
$var wire 1 H clk $end
$var wire 1 P pcen $end
$var wire 1 J reset $end
$var wire 1 L zero $end
$var wire 1 M regwrite $end
$var wire 1 N regdst $end
$var wire 1 Z pcwrite $end
$var wire 2 [ pcsrc [1:0] $end
$var wire 6 \ op [5:0] $end
$var wire 1 R memwrite $end
$var wire 1 S memtoreg $end
$var wire 1 T irwrite $end
$var wire 1 U iord $end
$var wire 6 ] funct [5:0] $end
$var wire 1 ^ branch $end
$var wire 2 _ alusrcb [1:0] $end
$var wire 1 X alusrca $end
$var wire 2 ` aluop [1:0] $end
$var wire 3 a alucontrol [2:0] $end
$scope module ad $end
$var wire 6 b funct [5:0] $end
$var wire 2 c aluop [1:0] $end
$var reg 3 d alucontrol [2:0] $end
$upscope $end
$scope module md $end
$var wire 1 H clk $end
$var wire 1 J reset $end
$var wire 1 M regwrite $end
$var wire 1 N regdst $end
$var wire 1 Z pcwrite $end
$var wire 2 e pcsrc [1:0] $end
$var wire 6 f op [5:0] $end
$var wire 1 R memwrite $end
$var wire 1 S memtoreg $end
$var wire 1 T irwrite $end
$var wire 1 U iord $end
$var wire 1 ^ branch $end
$var wire 2 g alusrcb [1:0] $end
$var wire 1 X alusrca $end
$var wire 2 h aluop [1:0] $end
$var reg 15 i controls [14:0] $end
$var reg 4 j nextstate [3:0] $end
$var reg 4 k state [3:0] $end
$upscope $end
$upscope $end
$scope module dp $end
$var wire 32 l adr [31:0] $end
$var wire 3 m alucontrol [2:0] $end
$var wire 1 X alusrca $end
$var wire 2 n alusrcb [1:0] $end
$var wire 1 H clk $end
$var wire 32 o instr [31:0] $end
$var wire 1 U iord $end
$var wire 1 T irwrite $end
$var wire 1 S memtoreg $end
$var wire 1 P pcen $end
$var wire 2 p pcsrc [1:0] $end
$var wire 32 q readdata [31:0] $end
$var wire 1 N regdst $end
$var wire 1 M regwrite $end
$var wire 1 J reset $end
$var wire 32 r writedata [31:0] $end
$var wire 1 L zero $end
$var wire 6 s op [5:0] $end
$var wire 6 t funct [5:0] $end
$upscope $end
$upscope $end
$scope module mux3 $end
$var wire 8 u d0 [7:0] $end
$var wire 8 v d1 [7:0] $end
$var wire 8 w d2 [7:0] $end
$var wire 2 x s [1:0] $end
$var wire 8 y y [7:0] $end
$upscope $end
$scope module mux4 $end
$var wire 8 z d0 [7:0] $end
$var wire 8 { d1 [7:0] $end
$var wire 8 | d2 [7:0] $end
$var wire 8 } d3 [7:0] $end
$var wire 2 ~ s [1:0] $end
$var reg 8 !" y [7:0] $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx !"
bz ~
bz }
bz |
bz {
bz z
bx y
bz x
bz w
bz v
bz u
bz t
bz s
bz r
bz q
bx p
bz o
bx n
bx m
bz l
bx k
bx j
bx i
bx h
bx g
bz f
bx e
bx d
bx c
bz b
bx a
bx `
bx _
x^
bz ]
bz \
bx [
xZ
bx Y
xX
bx W
bz V
xU
xT
xS
xR
bz Q
xP
bx O
xN
xM
zL
bz K
zJ
bz I
zH
bz G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
x;
x:
bx 9
bx 8
bx 7
bx 6
bx 5
x4
b0 3
bx 2
bx 1
x0
bx /
bx .
b0 -
1,
x+
x*
bx )
x(
x'
x&
x%
x$
bx #
x"
bx !
$end
#1
bz y
#10
b1 3
0,
#20
b111000011110000 2
04
b1000 .
b1000 7
b1000 =
b100011 /
b100011 8
b100011 A
1,
#30
b10 3
b1 -
0,
#40
1,
#50
b11 3
b10 -
0,
#60
1,
#70
b100 3
b11 -
0,
#80
1,
#90
b101 3
b100 -
0,
#100
bx 2
x4
b0xxxx .
b0xxxx 7
b0xxxx =
bx /
bx 8
bx A
1,
#110
b110 3
0,
#120
1,
#130
b111 3
0,
